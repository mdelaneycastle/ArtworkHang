<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Distance Measurement</title>
    <style>
        #container {
            position: relative;
            width: 500px; /* Set the width and height of your container */
            height: 500px;
            border: 1px solid black;
            background-size: cover;
            background-position: center;
        }
        .point {
            position: absolute;
            width: 10px; /* Set the size of your point */
            height: 10px;
            background-color: red; /* Set the color of your point */
            border-radius: 50%; /* Make the point circular */
        }
        #square {
            position: absolute;
            width: 100px; /* Initial size of the square (100x100 pixels) */
            height: 100px;
            cursor: move; /* Set cursor to indicate draggable element */
            background-image: url('image1.jpg'); /* Set background image */
            background-size: cover;
            background-position: center;
            box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5); /* Add shadow to the bottom right corner */
        }
    </style>
</head>
<body>
    <div id="container" onclick="handleClick(event)">
        <!-- Points will be dynamically added here -->
        <div id="square"></div>
    </div>

    <p id="distance"></p>

    <label for="realSize">Real Size of the Line (cm):</label>
    <input type="number" id="realSize" onchange="updateSquareSize()" step="any">

    <input type="file" id="imageInput" accept="image/*" onchange="setImageBackground(event)">

    <button onclick="resetMeasurement()">Reset</button>
    <button onclick="togglePoints()">Hide Points</button>

    <script>
        let points = [];
        const initialSquareSize = 101; // Predetermined size of the square in cm
        let isDragging = false;
        let offsetX, offsetY;
        let pointsVisible = true;

        function handleClick(event) {
            if (!pointsVisible) return; // Don't add points if points are hidden
            const container = document.getElementById('container');
            const rect = container.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            points.push({ x, y });

            if (points.length === 2) {
                const distance = Math.sqrt(
                    Math.pow(points[1].x - points[0].x, 2) +
                    Math.pow(points[1].y - points[0].y, 2)
                );

                document.getElementById('distance').innerText = `Distance: ${distance.toFixed(2)} pixels`;

                // Calculate the size of the square based on the real size of the line and predetermined square size
                const realSize = parseFloat(document.getElementById('realSize').value);
                if (!isNaN(realSize) && realSize > 0) {
                    const scale = (initialSquareSize / realSize) * distance; // Adjusted scale based on ratio
                    document.getElementById('square').style.width = `${scale}px`;
                    document.getElementById('square').style.height = `${scale}px`;
                }
            }

            if (points.length > 2) {
                points = points.slice(1); // Reset points array after the second click
            }

            drawPoint(x, y);
        }

        function drawPoint(x, y) {
            const container = document.getElementById('container');
            const point = document.createElement('div');
            point.className = 'point';
            point.style.left = `${x}px`;
            point.style.top = `${y}px`;
            container.appendChild(point);
        }

        function resetMeasurement() {
            points = [];
            const container = document.getElementById('container');
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            document.getElementById('distance').innerText = '';
            container.style.backgroundImage = ''; // Reset background image
        }

        function updateSquareSize() {
            const realSize = parseFloat(document.getElementById('realSize').value);
            if (!isNaN(realSize) && realSize > 0) {
                // Recalculate the size of the square based on the real size of the line
                const distance = parseFloat(document.getElementById('distance').innerText.split(':')[1]);
                const scale = (initialSquareSize / realSize) * distance; // Adjusted scale based on ratio
                document.getElementById('square').style.width = `${scale}px`;
                document.getElementById('square').style.height = `${scale}px`;
            }
        }

        function setImageBackground(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                const imageData = event.target.result;
                document.getElementById('container').style.backgroundImage = `url(${imageData})`;
            };
            reader.readAsDataURL(file);
        }

        const square = document.getElementById('square');

        square.addEventListener('mousedown', startDrag);
        square.addEventListener('mouseup', endDrag);

        function startDrag(event) {
            isDragging = true;
            offsetX = event.clientX - square.getBoundingClientRect().left;
            offsetY = event.clientY - square.getBoundingClientRect().top;
            document.addEventListener('mousemove', drag);
        }

        function endDrag() {
            isDragging = false;
            document.removeEventListener('mousemove', drag);
        }

        function drag(event) {
            if (isDragging) {
                const container = document.getElementById('container');
                const rect = container.getBoundingClientRect();
                let newX = event.clientX - rect.left - offsetX;
                let newY = event.clientY - rect.top - offsetY;

                // Ensure the square stays within the container
                newX = Math.max(0, Math.min(newX, container.clientWidth - square.offsetWidth));
                newY = Math.max(0, Math.min(newY, container.clientHeight - square.offsetHeight));

                square.style.left = `${newX}px`;
                square.style.top = `${newY}px`;
            }
        }

        function togglePoints() {
            const points = document.getElementsByClassName('point');
            for (let i = 0; i < points.length; i++) {
                points[i].style.display = points[i].style.display === 'none' ? 'block' : 'none';
            }
            pointsVisible = !pointsVisible; // Toggle points visibility flag
        }
    </script>
</body>
</html>
